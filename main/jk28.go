package main

//极客时间28讲,这节课巩固理论,27已经有了两个例子
func main() {

	// 问题1:
	// 条件变量的wait方法做了什么
	// 回答:  1.调用它所属的goroutine加入到当前条件变量的通知队列中,
	//        2.解锁当前的条件变量基于的哪个互斥锁(wait内部解锁了互斥锁c.l.Lock.unlock())
	//        3.让当前的goroutine处于阻塞状态,等通知信号(signal/broadcast)来的时候再决定是否唤醒它.此时我的goroutine是阻塞在wait方法的
	//        4.如果通知信号到来决定唤醒这个goroutine,那么就在唤醒之后重新锁定当前变量的基于的互斥锁
	//        5.加锁以后就可以对临界区进行操作了,goroutine也就会继续执行后面的代码了

	// 为什么先加锁才可以调用wait方法
	//  1.wait锁的内部先解锁,避免引发panic
	//  2.解铃还须系铃人,别的goroutine帮忙解锁可能会重复解锁引发panic
	//  3.只有自救解锁,然后加入等待唤醒的队列,然后其他goroutine操作临界区

	// for语句包含wait语句
	//  答案: 如果一个goroutine接到通知被唤醒,但却发现共享资源的状态,依然不符合它的要求,那么就应该
	//  再次调用条件变量的wait方法,继续等待下次通知的到来

	// 问题2: signal和broadcast方法的区别
	// 回答:  这两个方法都是来发送通知的,不同的是,发送一个通知还是多个通知
	//        发送的唤醒通知具有时效性,goroutine阻塞之后发送才可以(唤醒的一般取等待通知的队列头部)
	//        通常要写在互斥锁解锁之后
}
